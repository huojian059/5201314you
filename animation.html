<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>粉色爱心粒子效果</title>
  <!-- 保留鼠标滑动和点击爱心效果（外部文件） -->
  <script src="https://cdn.jsdelivr.net/gh/zyoushuo/Blog/hexo/js/mouse_slide.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/zyoushuo/Blog/hexo/js/clicklove.js"></script>
  <style>
    /* 渐变背景层，始终处于最底层 */
    .background-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, #1d2b64, #f8cdda);
      z-index: -1;
      animation: backgroundBreath 30s infinite alternate;
    }
    @keyframes backgroundBreath {
      0% { filter: brightness(1); }
      100% { filter: brightness(1.2); }
    }

    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }
    /* 层级控制 */
    #pinkboard {
      position: absolute;
      z-index: 3; /* 粉色粒子画布位于 fallingHeartsCanvas 之上 */
    }
    #fallingHeartsCanvas {
      position: absolute;
      z-index: 2;
    }
    .namebox {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 4;
      pointer-events: none;
      color: #fff;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
  </style>
</head>
<body>
  <!-- 渐变背景 -->
  <div class="background-layer"></div>
  <!-- 粉色爱心粒子画布 -->
  <canvas id="pinkboard"></canvas>
  <!-- 居中文字 -->
  <div class="namebox">
    <h1>XX&#10084;&#65039;XXX</h1>
  </div>
  
  <!-- 主爱心粒子系统 -->
  <script>
    // 配置参数
    var settings = {
      particles: {
        length: 500,      // 粒子数量
        duration: 2,      // 粒子存活时间（秒）
        velocity: 100,    // 初始速度
        effect: -0.75,    // 加速度系数（产生缓动效果）
        size: 30          // 基础粒子大小（后续随生命周期变化）
      }
    };

    // 定义基础点类
    var Point = function(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    };
    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };
    Point.prototype.length = function(len) {
      if (len === undefined)
        return Math.sqrt(this.x * this.x + this.y * this.y);
      this.normalize();
      this.x *= len;
      this.y *= len;
      return this;
    };
    Point.prototype.normalize = function() {
      var len = this.length();
      this.x /= len;
      this.y /= len;
      return this;
    };

    // 生成心形路径的函数
    // 公式：x = 160*sin³(t)
    //      y = 130*cos(t) - 50*cos(2t) - 20*cos(3t) - 10*cos(4t) + 25
    function pointOnHeart(t) {
      return new Point(
        160 * Math.pow(Math.sin(t), 3),
        130 * Math.cos(t) - 50 * Math.cos(2*t) - 20 * Math.cos(3*t) - 10 * Math.cos(4*t) + 25
      );
    }

    // 粒子类，绘制时根据生命周期做缓动缩放、淡出，同时动态调整颜色
    var Particle = function() {
      this.position = new Point();
      this.velocity = new Point();
      this.acceleration = new Point();
      this.age = 0;
      // 初始颜色仅作占位
      this.color = "#ff30c5";
    };
    Particle.prototype.initialize = function(x, y, dx, dy) {
      this.position.x = x;
      this.position.y = y;
      this.velocity.x = dx;
      this.velocity.y = dy;
      // 根据初始速度计算加速度，实现缓动效果
      this.acceleration.x = dx * settings.particles.effect;
      this.acceleration.y = dy * settings.particles.effect;
      this.age = 0;
    };
    Particle.prototype.update = function(deltaTime) {
      this.position.x += this.velocity.x * deltaTime;
      this.position.y += this.velocity.y * deltaTime;
      this.velocity.x += this.acceleration.x * deltaTime;
      this.velocity.y += this.acceleration.y * deltaTime;
      this.age += deltaTime;
    };
    // 绘制时根据生命周期做缓动缩放和淡出，同时动态调整颜色
    Particle.prototype.draw = function(ctx) {
      // 缓动函数（ease-out）
      function ease(t) {
        return (--t) * t * t + 1;
      }
      var progress = this.age / settings.particles.duration;
      var scale = ease(progress);
      // 粒子大小随生命周期变化
      var size = settings.particles.size * scale;
      // 透明度淡出
      ctx.globalAlpha = 1 - progress;
      
      // 根据进度动态调整颜色：保持基调为粉色（Hue 330），光度随进度增加
      var hue = 330;
      var saturation = 80;
      var lightness = 60 + 10 * progress;
      ctx.fillStyle = "hsl(" + hue + ", " + saturation + "%, " + lightness + "%)";

      ctx.save();
      ctx.translate(this.position.x, this.position.y);
      ctx.scale(scale, scale);

      // 绘制心形路径，居中绘制
      var s = settings.particles.size;
      function toCentered(t) {
        var p = pointOnHeart(t);
        return {
          x: (s / 2 + p.x * s / 350) - s / 2,
          y: (s / 2 - p.y * s / 350) - s / 2
        };
      }
      ctx.beginPath();
      var t = -Math.PI;
      var p = toCentered(t);
      ctx.moveTo(p.x, p.y);
      while(t < Math.PI) {
        t += 0.01;
        p = toCentered(t);
        ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    };

    // 粒子池，优化性能：循环使用固定数量的粒子对象
    var ParticlePool = function(length) {
      this.particles = new Array(length);
      for (var i = 0; i < length; i++) {
        this.particles[i] = new Particle();
      }
      this.firstActive = 0;
      this.firstFree = 0;
      this.duration = settings.particles.duration;
      this.poolLength = length;
    };
    ParticlePool.prototype.add = function(x, y, dx, dy) {
      this.particles[this.firstFree].initialize(x, y, dx, dy);
      this.firstFree++;
      if (this.firstFree === this.poolLength)
        this.firstFree = 0;
      if (this.firstActive === this.firstFree)
        this.firstActive++;
      if (this.firstActive === this.poolLength)
        this.firstActive = 0;
    };
    ParticlePool.prototype.update = function(deltaTime) {
      var p = this.particles;
      // 更新所有活跃粒子
      if (this.firstActive < this.firstFree) {
        for (var i = this.firstActive; i < this.firstFree; i++) {
          p[i].update(deltaTime);
        }
      } else {
        for (var i = this.firstActive; i < this.poolLength; i++) {
          p[i].update(deltaTime);
        }
        for (var i = 0; i < this.firstFree; i++) {
          p[i].update(deltaTime);
        }
      }
      // 回收生命周期结束的粒子
      while (p[this.firstActive].age >= this.duration && this.firstActive !== this.firstFree) {
        this.firstActive++;
        if (this.firstActive === this.poolLength)
          this.firstActive = 0;
      }
    };
    ParticlePool.prototype.draw = function(ctx) {
      var p = this.particles;
      if (this.firstActive < this.firstFree) {
        for (var i = this.firstActive; i < this.firstFree; i++) {
          p[i].draw(ctx);
        }
      } else {
        for (var i = this.firstActive; i < this.poolLength; i++) {
          p[i].draw(ctx);
        }
        for (var i = 0; i < this.firstFree; i++) {
          p[i].draw(ctx);
        }
      }
    };

    // 主渲染函数
    (function(canvas) {
      var ctx = canvas.getContext("2d");
      var pool = new ParticlePool(settings.particles.length);
      var particleRate = settings.particles.length / settings.particles.duration;
      var time;

      // 每帧生成一定数量的粒子，粒子起始位置在画布中心沿心形轨迹偏移
      function render() {
        requestAnimationFrame(render);
        var now = Date.now() / 1000;
        var deltaTime = now - (time || now);
        time = now;
        // 清除整个画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 根据时间间隔生成粒子
        var count = particleRate * deltaTime;
        for (var i = 0; i < count; i++) {
          // t 取值范围 [-π, π]
          var t = Math.PI - 2 * Math.PI * Math.random();
          var pos = pointOnHeart(t);
          var dir = pos.clone().length(settings.particles.velocity);
          // 将心形曲线偏移到画布中心
          pool.add(canvas.width/2 + pos.x, canvas.height/2 - pos.y, dir.x, -dir.y);
        }
        pool.update(deltaTime);
        pool.draw(ctx);
      }

      function onResize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", onResize);
      onResize();
      setTimeout(render, 10);
    })(document.getElementById("pinkboard"));
  </script>

  <!-- 七彩小心心雨动画（完整保留，去掉绿色） -->
  <script>
    // 定义一个辅助函数，用于生成随机色相（排除绿色：90～150 度）
    function getRandomHueExcludingGreen() {
      var hue;
      do {
        hue = Math.floor(Math.random() * 360);
      } while(hue >= 90 && hue <= 150);
      return hue;
    }
    (function() {
      var heartsCanvas = document.createElement("canvas");
      heartsCanvas.id = "fallingHeartsCanvas";
      heartsCanvas.style.position = "absolute";
      heartsCanvas.style.top = "0";
      heartsCanvas.style.left = "0";
      heartsCanvas.style.width = "100%";
      heartsCanvas.style.height = "100%";
      heartsCanvas.style.pointerEvents = "none";
      document.body.appendChild(heartsCanvas);

      var ctx = heartsCanvas.getContext("2d");
      function resizeHeartsCanvas() {
        heartsCanvas.width = window.innerWidth;
        heartsCanvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resizeHeartsCanvas);
      resizeHeartsCanvas();

      function FallingHeart() {
        this.x = Math.random() * heartsCanvas.width;
        this.y = -Math.random() * heartsCanvas.height;
        this.size = Math.random() * 30 + 10;
        this.speedY = Math.random() * 100 + 50;
        this.sway = (Math.random() - 0.5) * 30;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
        this.color = "hsl(" + getRandomHueExcludingGreen() + ", 80%, 60%)";
      }
      FallingHeart.prototype.update = function(delta) {
        this.y += this.speedY * delta;
        this.x += this.sway * delta;
        this.rotation += this.rotationSpeed * delta;
        if (this.y - this.size > heartsCanvas.height) {
          this.y = -this.size;
          this.x = Math.random() * heartsCanvas.width;
          this.size = Math.random() * 30 + 10;
          this.speedY = Math.random() * 100 + 50;
          this.sway = (Math.random() - 0.5) * 30;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.2;
          this.color = "hsl(" + getRandomHueExcludingGreen() + ", 80%, 60%)";
        }
      };
      FallingHeart.prototype.draw = function(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        var s = this.size;
        ctx.beginPath();
        ctx.moveTo(0, s * 0.35);
        ctx.bezierCurveTo(-s * 0.65, 0, -s * 0.65, s * 0.8, 0, s);
        ctx.bezierCurveTo(s * 0.65, s * 0.8, s * 0.65, 0, 0, s * 0.35);
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
      };

      var hearts = [];
      for (var i = 0; i < 60; i++) {
        hearts.push(new FallingHeart());
      }
      var lastTime = performance.now();
      function animateHearts() {
        var now = performance.now();
        var delta = (now - lastTime) / 1000;
        lastTime = now;
        ctx.clearRect(0, 0, heartsCanvas.width, heartsCanvas.height);
        for (var i = 0; i < hearts.length; i++) {
          hearts[i].update(delta);
          hearts[i].draw(ctx);
        }
        requestAnimationFrame(animateHearts);
      }
      requestAnimationFrame(animateHearts);
    })();
  </script>
</body>
</html>
